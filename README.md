Selected Projects and Reflection
1. Milestone One - Blinking LEDs
Summary of the Project and Problem Solved:
This milestone focused on using Code Composer Studio (CCS) to edit, compile, and debug code for the CC32xx board. The objective was to blink the green and yellow LEDs, introducing the PWM driver and exploring the CCS project structure and code generator. This project solved the problem of understanding and applying PWM principles to achieve precise LED control.

What I Did Particularly Well:
I successfully integrated the CCS code generator with the PWM driver to control LED blinking patterns effectively. My debugging skills allowed me to quickly identify and fix errors during the compilation and execution phases.

Where I Could Improve:
While I was able to debug effectively, I could improve by writing more detailed inline comments to explain my code, making it more understandable for future reviews.

Tools and Resources Added to My Support Network:
I deepened my familiarity with CCS, PWM driver documentation, and debugging techniques. Additionally, I explored community forums for troubleshooting tips, which will remain a valuable resource.

Transferable Skills:
The ability to work with PWM drivers, troubleshoot embedded systems, and use CCS efficiently are skills that can be directly applied to future hardware programming projects.

How I Made the Project Maintainable, Readable, and Adaptable:
I used consistent variable naming conventions, structured the code into clear, modular functions, and included comments to explain the logic behind each step. This ensured that the project could be easily adapted for future enhancements.

2. Milestone Two - State Machine for LED Control
Summary of the Project and Problem Solved:
In this milestone, the objective was to control the red LEDs in the lower right corner of the CC32xx board using a state machine. The system responded to console inputs ("ON" and "OFF") to control the LED state, using only one byte of RAM. This project tackled the challenge of implementing a resource-efficient state machine.

What I Did Particularly Well:
I designed an efficient state machine that used minimal resources while maintaining functionality. Additionally, I implemented robust input handling to ensure the system accurately responded to "ON" and "OFF" commands.

Where I Could Improve:
I could enhance the project by implementing additional error-handling mechanisms for invalid inputs and providing more detailed documentation on the state machine's logic.

Tools and Resources Added to My Support Network:
I expanded my understanding of UART communication and state machine design, leveraging UART documentation and online tutorials. These resources will be invaluable for future embedded systems projects.

Transferable Skills:
Designing efficient state machines and working with UART for serial communication are highly transferable skills, especially for projects involving real-time systems and user interactions.

How I Made the Project Maintainable, Readable, and Adaptable:
I modularized the state machine logic and ensured all UART communication code was reusable. The code was well-documented with comments explaining the purpose of each function and key decision points, making it easy to adapt or extend.

By reflecting on these projects, I have demonstrated my abilities in embedded systems programming, problem-solving, and resource-efficient design. These skills, along with the tools and practices Iâ€™ve developed, will significantly support my future coursework and professional endeavors.
